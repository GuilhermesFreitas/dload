#!/usr/bin/env python3

import os
import subprocess
import sys
import re
import shutil
import logging
from pathlib import Path
from datetime import datetime

logging.basicConfig(
    filename=Path.home() / '.dload.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    encoding='utf-8'
)

logger = logging.getLogger('dload')

def ler_diretorio_usuario(var, padrao):
    config = Path.home() / ".config" / "user-dirs.dirs"
    if config.exists():
        try:
            with open(config, "r", encoding="utf-8") as f:
                for linha in f:
                    if var in linha:
                        caminho = re.findall(r'"(.*?)"', linha)
                        if caminho:
                            return Path(caminho[0].replace("$HOME", str(Path.home()))).expanduser()
        except Exception as e:
            logger.warning(f"Erro ao ler {config}: {e}")
    return Path(padrao)

DESTINOS = {
    "1": ler_diretorio_usuario("XDG_DOWNLOAD_DIR", Path.home() / "Downloads"),
    "2": ler_diretorio_usuario("XDG_VIDEOS_DIR", Path.home() / "V√≠deos"),
    "3": ler_diretorio_usuario("XDG_MUSIC_DIR", Path.home() / "M√∫sica"),
}

def instalar_dependencia(pacote):
    try:
        if Path("/etc/arch-release").exists():
            subprocess.run(["sudo", "pacman", "-Sy", "--noconfirm", pacote], check=True)
        else:
            subprocess.run([sys.executable, "-m", "pip", "install", "--user", pacote], check=True)
        return True
    except subprocess.CalledProcessError:
        return False

def verificar_dependencias():
    dependencias = {
        "yt-dlp": {
            "arch": "yt-dlp",
            "outros": "yt-dlp",
            "mensagem": "Necess√°rio para downloads"
        },
        "ffmpeg": {
            "arch": "ffmpeg",
            "outros": "ffmpeg-python",
            "mensagem": "Necess√°rio para convers√µes"
        }
    }

    for cmd, info in dependencias.items():
        if not shutil.which(cmd):
            print(f"\n‚ùå {cmd} n√£o encontrado ({info['mensagem']})")
            print("üîÑ Tentando instala√ß√£o autom√°tica...")
            
            if Path("/etc/arch-release").exists():
                if not instalar_dependencia(info["arch"]):
                    print(f"\n‚ö†Ô∏è Falha na instala√ß√£o autom√°tica para Arch Linux")
                    print(f"Instale manualmente com: sudo pacman -S {info['arch']}")
                    sys.exit(1)
            else:
                if not instalar_dependencia(info["outros"]):
                    print(f"\n‚ö†Ô∏è Falha na instala√ß√£o autom√°tica")
                    print(f"Instale manualmente com: pip install --user {info['outros']}")
                    sys.exit(1)
            
            print(f"‚úÖ {cmd} instalado com sucesso!")

def obter_titulo_video(url):
    try:
        resultado = subprocess.run([
            "yt-dlp", "--get-title", "--no-warnings", url
        ], capture_output=True, text=True, check=True)
        return resultado.stdout.strip()
    except subprocess.CalledProcessError as e:
        logger.warning(f"Erro ao obter t√≠tulo: {e.stderr}")
        return None

def solicitar_url():
    url = input("\n üåç Cole a URL do v√≠deo: ").strip()
    if not url:
        logger.error("URL vazia fornecida")
        print("‚ùå URL n√£o pode ser vazia!")
        return None
    return url

def confirmar(mensagem="‚úîÔ∏è  Confirmar? [S/n]: "):
    return input(mensagem).strip().lower() in ("", "s")

def obter_pasta_destino(opcao):
    caminho = Path(DESTINOS.get(opcao, DESTINOS["1"]))
    try:
        caminho.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        logger.warning(f"Falha ao criar pasta {caminho}: {e}")
    return caminho

def verificar_espaco(pasta, tamanho_minimo):
    try:
        stat = shutil.disk_usage(pasta)
        livre_mb = stat.free // (1024 * 1024)
        if livre_mb < tamanho_minimo:
            print(f"‚ö†Ô∏è  Espa√ßo insuficiente! Livre: {livre_mb}MB (Necess√°rio: {tamanho_minimo}MB)")
            logger.warning(f"Espa√ßo insuficiente em {pasta} ({livre_mb}MB < {tamanho_minimo}MB)")
            return False
        return True
    except Exception as e:
        logger.error(f"Erro ao verificar espa√ßo: {e}")
        print(f"‚ùå Erro ao verificar espa√ßo em disco: {e}")
        return False

def salvar_no_historico(url, destino, tipo):
    try:
        with open(Path.home()/".dload_history", "a", encoding='utf-8') as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            titulo = obter_titulo_video(url) or "Desconhecido"
            f.write(f"{timestamp} | {tipo} | {titulo[:50]}... | {url} | {destino}\n")
    except Exception as e:
        logger.error(f"Erro ao registrar hist√≥rico: {e}")

def exibir_historico():
    hist = Path.home() / ".dload_history"
    if not hist.exists():
        print("‚ÑπÔ∏è  Nenhum hist√≥rico encontrado")
        return
    try:
        with open(hist, "r", encoding='utf-8') as f:
            print("\nüìú Hist√≥rico de Downloads:")
            print("="*80)
            for linha in f.readlines()[-10:]:
                print(linha.strip())
            print("="*80)
    except Exception as e:
        logger.error(f"Erro ao ler hist√≥rico: {e}")
        print("‚ùå Erro ao ler hist√≥rico")

def limpar_historico():
    hist = Path.home() / ".dload_history"
    if hist.exists():
        try:
            hist.unlink()
            print("üßπ Hist√≥rico apagado com sucesso.")
            logger.info("Hist√≥rico apagado pelo usu√°rio.")
        except Exception as e:
            logger.error(f"Erro ao apagar hist√≥rico: {e}")
            print(f"‚ùå Erro ao apagar hist√≥rico: {e}")
    else:
        print("‚ÑπÔ∏è Nenhum hist√≥rico para apagar.")

def executar_download(cmd, url, destino, tipo):
    print("\n‚è≥ Iniciando download...")
    logger.info(f"Iniciando download de {tipo.lower()}: {url}")

    try:
        processo = subprocess.run(cmd, text=True)
        if processo.returncode == 0:
            salvar_no_historico(url, destino, tipo)
            print("\n‚úÖ Download conclu√≠do!")
        else:
            print("\n‚ùå Erro no download.")
    except Exception as e:
        logger.error(f"Falha no subprocesso: {e}", exc_info=True)
        print(f"\n‚ùå Erro ao executar comando: {e}")

def baixar_audio():
    try:
        url = solicitar_url()
        if not url:
            return

        titulo = obter_titulo_video(url)
        if titulo:
            print(f"\nüìã T√≠tulo: {titulo}")
            if not confirmar():
                return
        else:
            print("‚ö†Ô∏è  N√£o foi poss√≠vel verificar o t√≠tulo")
            if not confirmar("Continuar mesmo assim? [s/N]: "):
                return

        print("\n üìÇ Escolha onde salvar:\n1 - Downloads\n2 - V√≠deos\n3 - M√∫sicas")
        destino = obter_pasta_destino(input("Digite o n√∫mero (1-3): ").strip())

        if not verificar_espaco(destino, 200):
            return

        cmd = [
            "yt-dlp", "-x", "--audio-format", "mp3",
            "--audio-quality", "0", "--embed-thumbnail",
            "--newline", "--no-warnings",
            "-o", f"{destino}/%(title)s.%(ext)s", url
        ]

        executar_download(cmd, url, destino, "√Åudio")

    except Exception as e:
        logger.error(f"Erro inesperado: {e}", exc_info=True)
        print(f"‚ùå Ocorreu um erro: {e}")

def baixar_video():
    try:
        url = solicitar_url()
        if not url:
            return

        titulo = obter_titulo_video(url)
        if titulo:
            print(f"\nüìã T√≠tulo: {titulo}")
            if not confirmar():
                return
        else:
            print("‚ö†Ô∏è  N√£o foi poss√≠vel verificar o t√≠tulo")
            if not confirmar("Continuar mesmo assim? [s/N]: "):
                return

        print("\n üìÇ Escolha onde salvar:\n1 - Downloads\n2 - V√≠deos\n3 - M√∫sicas")
        destino = obter_pasta_destino(input("Digite o n√∫mero (1-3): ").strip())

        if not verificar_espaco(destino, 500):
            return

        if input("\nüîç Listar formatos dispon√≠veis? [s/N]: ").lower() == "s":
            subprocess.run(["yt-dlp", "-F", url], check=True)
            formato = input("\n‚å®Ô∏è Digite o ID do formato ou Enter para melhor qualidade: ").strip()
        else:
            formato = ""

        cmd = [
            "yt-dlp", "--merge-output-format", "mp4",
            "--embed-thumbnail", "--newline", "--no-warnings",
            "-o", f"{destino}/%(title)s.%(ext)s"
        ]

        if formato:
            cmd.extend(["-f", formato])
        cmd.append(url)

        executar_download(cmd, url, destino, "V√≠deo")

    except Exception as e:
        logger.error(f"Erro inesperado: {e}", exc_info=True)
        print(f"‚ùå Ocorreu um erro: {e}")

def main():
    print("""
    ========================================
          Dload - Fastdownload      
    ========================================
""")
    logger.info("Iniciando Dload")

    verificar_dependencias()

    try:
        while True:
            print("""
1. üéµ Baixar √Åudio (MP3)
2. üéÆ Baixar V√≠deo (MP4)
3. üìú Mostrar Hist√≥rico
4. üßπ Limpar Hist√≥rico
5. ‚ùå Sair
""")
            escolha = input("Escolha (1-5): ").strip()

            if escolha == "1":
                baixar_audio()
            elif escolha == "2":
                baixar_video()
            elif escolha == "3":
                exibir_historico()
            elif escolha == "4":
                limpar_historico()
            elif escolha == "5":
                logger.info("Aplica√ß√£o encerrada pelo usu√°rio")
                print("üëã Saindo...")
                sys.exit(0)
            else:
                print("‚ùå Op√ß√£o inv√°lida. Tente novamente.")
    except KeyboardInterrupt:
        print("\nüëã Encerrando...")
        sys.exit(0)
    except Exception as e:
        logger.critical(f"Erro fatal: {e}", exc_info=True)
        print(f"‚ùå Erro cr√≠tico: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()